<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Lottie to MOV - SVG Renderer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.10.1/lottie.min.js"></script>
</head>

<body>
    <div id="lottie-container" style="position: absolute; top: 0; left: 0;"></div>
    <canvas id="canvas" style="position: absolute; top: 0; left: 0; display: none;"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        // API для конвертации Lottie через SVG рендерер
        window.convertLottieToVideo = async function(jsonData, options = {}) {
            const container = document.getElementById('lottie-container');
            const canvas = document.getElementById('canvas');

            const ctx = canvas.getContext('2d', {
                alpha: true,
                willReadFrequently: false
            });

            // Установить размеры
            const width = options.width || jsonData.w || 512;
            const height = options.height || jsonData.h || 512;

            canvas.width = width;
            canvas.height = height;
            container.style.width = width + 'px';
            container.style.height = height + 'px';

            container.innerHTML = '';
            ctx.clearRect(0, 0, width, height);

            return new Promise((resolve, reject) => {
                try {
                    // SVG рендерер для качественных градиентов
                    const animation = lottie.loadAnimation({
                        container: container,
                        renderer: 'svg',
                        loop: false,
                        autoplay: false,
                        animationData: jsonData,
                        rendererSettings: {
                            preserveAspectRatio: 'xMidYMid meet',
                            progressiveLoad: false,
                            hideOnTransparent: true,
                        },
                    });

                    const speed = options.speed || 1;
                    if (speed !== 1) animation.setSpeed(speed);

                    // PNG sequence метод
                    handlePngSequence(animation, container, canvas, ctx, options, resolve, reject);

                } catch (error) {
                    reject(error);
                }
            });
        };

        // PNG sequence: рендерим SVG → Canvas → PNG
        async function handlePngSequence(animation, container, canvas, ctx, options, resolve, reject) {
            const totalFrames = animation.totalFrames;
            const framerate = options.framerate || animation.frameRate;
            const pngDataUrls = [];
            let currentFrame = 0;

            console.log(`SVG рендеринг: ${totalFrames} кадров @ ${framerate} fps`);

            animation.goToAndStop(0, true);

            async function captureFrame() {
                if (currentFrame >= totalFrames) {
                    console.log(`✓ Все ${totalFrames} кадров отрендерены`);

                    resolve({
                        success: true,
                        frames: pngDataUrls,
                        duration: animation.getDuration(),
                        totalFrames: totalFrames,
                        fps: framerate,
                        width: canvas.width,
                        height: canvas.height,
                    });
                    return;
                }

                try {
                    animation.goToAndStop(currentFrame, true);
                    await new Promise(resolve => setTimeout(resolve, 50));

                    const svgElement = container.querySelector('svg');
                    if (!svgElement) {
                        throw new Error('SVG элемент не найден');
                    }

                    await drawSVGOnCanvas(svgElement, ctx, canvas.width, canvas.height);

                    const dataUrl = canvas.toDataURL('image/png');
                    pngDataUrls.push(dataUrl);

                    currentFrame++;

                    if (currentFrame % 10 === 0 || currentFrame === totalFrames) {
                        console.log(`  ${currentFrame}/${totalFrames} кадров`);
                    }

                    setTimeout(captureFrame, 0);

                } catch (error) {
                    reject(new Error(`Ошибка на кадре ${currentFrame}: ${error.message}`));
                }
            }

            captureFrame();
        }

        // Рисование SVG на Canvas
        async function drawSVGOnCanvas(svgElement, ctx, width, height) {
            return new Promise((resolve, reject) => {
                try {
                    ctx.clearRect(0, 0, width, height);

                    const svgClone = svgElement.cloneNode(true);
                    svgClone.setAttribute('width', width);
                    svgClone.setAttribute('height', height);

                    const svgString = new XMLSerializer().serializeToString(svgClone);
                    const svgDataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);

                    const img = new Image();

                    img.onload = () => {
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve();
                    };

                    img.onerror = () => {
                        reject(new Error('Не удалось загрузить SVG'));
                    };

                    img.src = svgDataUrl;

                } catch (error) {
                    reject(error);
                }
            });
        }

        window.converterReady = true;
    </script>
</body>

</html>